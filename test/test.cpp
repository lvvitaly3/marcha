// test.cpp : 20:26 04.03.2021
// как это работает:
// к пакету добавляется поле размером UINT32_T - это последовательный индекс
// если будет переполнение - то продлжается счет с 0
// можно добавить еще флаги начало работы , продолжение, конец(не реализовано).
// Все пакеты нумеруютя последовательно - если будет разделение на несколько потоков,
// то все равно пакеты в потоках будут расположены по возрастанию
// в каждом потоке имется своя очередь, куда складыватся пакеты
// Идея заключается в том, что пакет который имеет минимальный номер на вершине очереди,
// из всех существующих очередей, является текущим порядковым номером
// шаги реализации :
// - запись в очередь пакета
// - просмотр вершин очередей для нахождения след пакета
// - если пакет найден - удаление пакета из очереди
// 
//  Можно задачу решить еще проще, без очередей(реализуется элементарно):
//  формат пакета остается таким-же
//  в каждом потоке сравнивать индекс приходящего пакета с ожидаемым индексом.
//  если сравнение прошло успешно(true) - новый ожидаемый индекс вычисляется из индекса полученного пакета
//  и читаем следующий пакет из сети в данном потоке, если проверка false 
//  инициируем проверку в других потоках (condition_variable notify_all())
//  оставливаем чтение из сети  (condition_variable wait);
//  см sync.cpp (#define _SIMPLE_)
// для более быстрой работы необходимо заменить condition_variable на другой алгоритм

#include "PrepareData.h"
#include "SyncData.h"
#include "sync.h"

//#define _SIMPLE_

#ifdef _SIMPLE_
int main()
{
	try {
		sync sync_;

		time_t tm = time(NULL);
		while (time(NULL) - tm < 100) {
			Sleep(1000);
		}
	}
	catch (...) {
		std::cout << "Error sync \n";
		return -1;
	}
	return 0;
}
#else 
int main()
{
	// Создание очередей для промежуточного хранения генерируемых пакетов.
	// Количество очередей равно _MAXNUM_THREADS_.
	// очередь не оптимальна по скорости обработки (есть другая)
	RingQueues::Create();
	try {
		PrepareData  prepareData;
		Sleep(5);
		SyncData  syncData;
          
		time_t tm = time(NULL);
		while (time(NULL) - tm < 100) {
			Sleep(1000);
		}

	}
	catch (...) {
		std::cout << "Error PrepareData \n";
		return -1;
	}

	return 0;
}

#endif //_SIMPLE_
